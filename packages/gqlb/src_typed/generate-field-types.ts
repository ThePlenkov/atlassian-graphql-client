/**
 * Generate fully typed FieldFn types from GraphQL schema
 * 
 * Key insight: Field selections return a marker type, not the actual value!
 * The value type is only used for type inference, not the return type.
 */

import { GraphQLSchema, GraphQLObjectType, GraphQLField, isNonNullType, isListType, isScalarType, isEnumType, isObjectType, isUnionType, GraphQLOutputType, GraphQLUnionType, GraphQLNamedType } from 'graphql';

interface FieldInfo {
  name: string;
  typeName: string;
  isNonNull: boolean;
  isList: boolean;
  isScalar: boolean;
  hasArgs: boolean;
  argsTypeName: string | null;
  hasRequiredArgs: boolean;
}

function unwrapType(type: GraphQLOutputType): {
  baseType: GraphQLNamedType;
  isNonNull: boolean;
  isList: boolean;
} {
  let isNonNull = false;
  let isList = false;
  let current: GraphQLOutputType = type;

  if (isNonNullType(current)) {
    isNonNull = true;
    current = current.ofType;
  }

  if (isListType(current)) {
    isList = true;
    const listElement = current.ofType;
    if (isNonNullType(listElement)) {
      current = listElement.ofType;
    } else {
      current = listElement;
    }
  }

  return { baseType: current as GraphQLNamedType, isNonNull, isList };
}

function getFieldInfo(field: GraphQLField<unknown, unknown>, parentTypeName: string, referencedTypes: Set<string>): FieldInfo {
  const { baseType, isNonNull, isList } = unwrapType(field.type);
  const typeName = baseType.name;
  const isScalar = isScalarType(baseType) || isEnumType(baseType);
  
  if (isEnumType(baseType)) {
    referencedTypes.add(typeName);
  }
  
  const hasArgs = Object.keys(field.args).length > 0;
  const argsTypeName = hasArgs ? `${parentTypeName}${field.name.charAt(0).toUpperCase()}${field.name.slice(1)}Args` : null;
  const hasRequiredArgs = field.args.some(arg => isNonNullType(arg.type));

  return {
    name: field.name,
    typeName,
    isNonNull,
    isList,
    isScalar,
    hasArgs,
    argsTypeName,
    hasRequiredArgs
  };
}

function generateFieldType(field: FieldInfo): string {
  const { name, typeName, isNonNull, isList, isScalar, hasArgs, argsTypeName, hasRequiredArgs } = field;

  // All fields return FieldSelection<T> where T is the inferred result type
  // This marker type goes in the array, not the actual value!
  
  let resultType: string;
  if (isScalar) {
    const scalarMap: Record<string, string> = {
      'String': 'string',
      'Int': 'number',
      'Float': 'number',
      'Boolean': 'boolean',
      'ID': 'string',
      'DateTime': 'string'
    };
    const baseType = scalarMap[typeName] || typeName;
    resultType = isList ? `${baseType}[]` : baseType;
  } else {
    const baseType = `${typeName}Fields`;
    resultType = isList ? `${baseType}[]` : baseType;
  }
  
  if (!isNonNull) {
    resultType = `${resultType} | null`;
  }

  // Generate field signature
  // All fields return FieldSelection, which can be placed in the selection array
  // Args accept WithVariables to allow TypedVariable usage
  if (isScalar) {
    // Scalar field
    if (hasArgs) {
      if (hasRequiredArgs) {
        return `  ${name}: (args: WithVariables<${argsTypeName}>) => FieldSelection<${resultType}>;`;
      } else {
        return `  ${name}: (args?: WithVariables<${argsTypeName}>) => FieldSelection<${resultType}>;`;
      }
    } else {
      return `  ${name}: FieldSelection<${resultType}>;`;
    }
  } else {
    // Object field - requires selection
    const selectParam = `(obj: ${typeName}Fields) => ReadonlyArray<FieldSelection<unknown>>`;
    
    if (hasArgs) {
      if (hasRequiredArgs) {
        return `  ${name}: (args: WithVariables<${argsTypeName}>, select: ${selectParam}) => FieldSelection<${resultType}>;`;
      } else {
        return `  ${name}: {
    (select: ${selectParam}): FieldSelection<${resultType}>;
    (args: WithVariables<${argsTypeName}>, select: ${selectParam}): FieldSelection<${resultType}>;
  };`;
      }
    } else {
      return `  ${name}: (select: ${selectParam}) => FieldSelection<${resultType}>;`;
    }
  }
}

function generateTypeFields(type: GraphQLObjectType, referencedTypes: Set<string>): string {
  const fields = Object.values(type.getFields());
  const fieldInfos = fields.map(field => getFieldInfo(field, type.name, referencedTypes));
  
  const lines: string[] = [
    `export interface ${type.name}Fields {`
  ];
  
  for (const fieldInfo of fieldInfos) {
    lines.push(generateFieldType(fieldInfo));
  }
  
  lines.push('}');
  lines.push('');
  
  return lines.join('\n');
}

export interface GenerateFieldTypesOptions {
  /** GraphQL schema instance */
  schema: GraphQLSchema;
  /** Relative path from output file to schema-types.ts (generated by graphql-codegen) */
  schemaTypesImportPath: string;
  /**
   * Import path for helper types (FieldSelection, TypedVariable, WithVariables)
   * @default 'gqlb/typed' - Use this when consuming gqlb as a package
   * @example '../../../src_typed/field-types-helpers.js' - Use relative path when developing gqlb itself
   */
  helpersImportPath?: string;
}

/**
 * Generate TypeScript field types from a GraphQL schema
 * 
 * @param options - Configuration options
 * @returns Generated TypeScript code as string
 * 
 * @example
 * ```typescript
 * import { buildSchema } from 'graphql';
 * import { generateFieldTypes } from 'gqlb/typed';
 * 
 * const schema = buildSchema(`
 *   type Query {
 *     hello: String!
 *   }
 * `);
 * 
 * const code = generateFieldTypes({
 *   schema,
 *   schemaTypesImportPath: './schema-types.js'
 * });
 * ```
 */
export function generateFieldTypes(options: GenerateFieldTypesOptions): string {
  const { schema, schemaTypesImportPath, helpersImportPath = 'gqlb/typed' } = options;
  
  const argsTypes = new Set<string>();
  const referencedTypes = new Set<string>();
  
  const output: string[] = [
    '/**',
    ' * Generated field types for fully typed query builder',
    ' * DO NOT EDIT - Generated by generate-field-types.ts',
    ' */',
    '',
    '// Import and re-export helper types',
    `import type { FieldSelection, TypedVariable, WithVariables } from '${helpersImportPath}';`,
    'export type { FieldSelection, TypedVariable, WithVariables };',
    '',
    '// Import generated schema types',
    'import type {',
  ];

  // Scan all fields to collect types
  const typeMap = schema.getTypeMap();
  const objectTypes = Object.values(typeMap).filter(
    type => isObjectType(type) && !type.name.startsWith('__')
  ) as GraphQLObjectType[];

  // Collect args types
  const queryType = schema.getQueryType();
  const mutationType = schema.getMutationType();

  if (queryType) {
    Object.values(queryType.getFields()).forEach(field => {
      if (field.args.length > 0) {
        const argsTypeName = `Query${field.name.charAt(0).toUpperCase()}${field.name.slice(1)}Args`;
        argsTypes.add(argsTypeName);
      }
    });
  }

  if (mutationType) {
    Object.values(mutationType.getFields()).forEach(field => {
      if (field.args.length > 0) {
        const argsTypeName = `Mutation${field.name.charAt(0).toUpperCase()}${field.name.slice(1)}Args`;
        argsTypes.add(argsTypeName);
      }
    });
  }

  // Collect nested field args
  for (const type of objectTypes) {
    const fields = Object.values(type.getFields());
    fields.forEach(field => {
      getFieldInfo(field, type.name, referencedTypes);
      if (field.args.length > 0) {
        const argsTypeName = `${type.name}${field.name.charAt(0).toUpperCase()}${field.name.slice(1)}Args`;
        argsTypes.add(argsTypeName);
      }
    });
  }

  const allImports = [...Array.from(argsTypes), ...Array.from(referencedTypes)].sort();
  output.push(...allImports.map(t => `  ${t},`));
  output.push(`} from '${schemaTypesImportPath}';`);
  output.push('');

  // Generate object types
  for (const type of objectTypes) {
    output.push(generateTypeFields(type, referencedTypes));
  }

  // Generate union types
  const unionTypes = Object.values(typeMap).filter(
    type => isUnionType(type) && !type.name.startsWith('__')
  ) as GraphQLUnionType[];

  for (const unionType of unionTypes) {
    const possibleTypes = unionType.getTypes().map(t => `${t.name}Fields`).join(' | ');
    output.push(`export type ${unionType.name}Fields = ${possibleTypes};`);
    output.push('');
  }

  return output.join('\n');
}


/**
 * GraphQL Code Generator Plugin for gqlb Typed Builder
 * 
 * Generates TypeScript types in FieldFn<TSelection, TArgs, TRequired> format
 * for use with the runtime proxy-based query builder.
 */

import type { PluginFunction, PluginValidateFn } from '@graphql-codegen/plugin-helpers';
import type { 
  GraphQLSchema, 
  GraphQLNamedType,
  GraphQLObjectType, 
  GraphQLInterfaceType,
  GraphQLUnionType,
  GraphQLEnumType,
  GraphQLScalarType,
  GraphQLInputObjectType,
  GraphQLField,
  GraphQLType
} from 'graphql';

import {
  isObjectType,
  isInterfaceType,
  isUnionType,
  isEnumType,
  isScalarType,
  isInputObjectType,
  isListType,
  isNonNullType,
  getNamedType
} from 'graphql';

export interface TypedBuilderPluginConfig {
  /**
   * Custom scalar mappings
   * @example { DateTime: 'Date', JSON: 'unknown' }
   */
  scalars?: Record<string, string>;
  
  /**
   * Include __typename field in all object types
   */
  includeTypename?: boolean;
  
  /**
   * Prefix for generated type names
   */
  typePrefix?: string;
  
  /**
   * Suffix for generated type names
   */
  typeSuffix?: string;
}

/**
 * Plugin implementation
 */
export const plugin: PluginFunction<TypedBuilderPluginConfig> = (
  schema: GraphQLSchema,
  documents,
  config
) => {
  const lines: string[] = [];
  
  // Add header
  lines.push('/**');
  lines.push(' * Auto-generated TypeScript types for gqlb');
  lines.push(' * Generated by @graphql-codegen/cli with gqlb typed-builder plugin');
  lines.push(' * DO NOT EDIT MANUALLY');
  lines.push(' */');
  lines.push('');
  
  // Import FieldFn type
  lines.push('import type { FieldFn } from \'gqlb/typed\';');
  lines.push('');
  
  // Generate scalar type mappings
  lines.push('// Scalar type mappings');
  lines.push(...generateScalarTypes(config.scalars || {}));
  lines.push('');
  
  // Get all types from schema
  const typeMap = schema.getTypeMap();
  const types = Object.values(typeMap).filter(type => 
    !type.name.startsWith('__') // Skip introspection types
  );
  
  // Generate enums
  const enums = types.filter(isEnumType);
  if (enums.length > 0) {
    lines.push('// Enums');
    for (const enumType of enums) {
      lines.push(...generateEnumType(enumType, config));
    }
    lines.push('');
  }
  
  // Generate input types
  const inputTypes = types.filter(isInputObjectType);
  if (inputTypes.length > 0) {
    lines.push('// Input types');
    for (const inputType of inputTypes) {
      lines.push(...generateInputObjectType(inputType, config));
    }
    lines.push('');
  }
  
  // Generate object types (as FieldFn interfaces)
  const objectTypes = types.filter(isObjectType);
  if (objectTypes.length > 0) {
    lines.push('// Object types');
    for (const objectType of objectTypes) {
      lines.push(...generateObjectTypeFields(objectType, config, schema));
    }
    lines.push('');
  }
  
  // Generate interface types
  const interfaceTypes = types.filter(isInterfaceType);
  if (interfaceTypes.length > 0) {
    lines.push('// Interface types');
    for (const interfaceType of interfaceTypes) {
      lines.push(...generateInterfaceTypeFields(interfaceType, config, schema));
    }
    lines.push('');
  }
  
  // Generate union types
  const unionTypes = types.filter(isUnionType);
  if (unionTypes.length > 0) {
    lines.push('// Union types');
    for (const unionType of unionTypes) {
      lines.push(...generateUnionType(unionType, config));
    }
    lines.push('');
  }
  
  return lines.join('\n');
};

/**
 * Generate scalar type mappings
 */
function generateScalarTypes(scalars: Record<string, string>): string[] {
  const defaults: Record<string, string> = {
    String: 'string',
    Int: 'number',
    Float: 'number',
    Boolean: 'boolean',
    ID: 'string',
    ...scalars
  };
  
  const lines: string[] = [];
  for (const [graphqlType, tsType] of Object.entries(defaults)) {
    lines.push(`export type Scalar${graphqlType} = ${tsType};`);
  }
  
  return lines;
}

/**
 * Generate TypeScript type from GraphQL type
 */
function generateTypeReference(type: GraphQLType, config: TypedBuilderPluginConfig, forFieldFn: boolean = false): string {
  const isRequired = isNonNullType(type);
  const nullableType = isRequired ? type.ofType : type;
  
  if (isListType(nullableType)) {
    const elementType = generateTypeReference(nullableType.ofType, config, false);
    return `Array<${elementType}>`;
  }
  
  const namedType = getNamedType(nullableType);
  const typeName = namedType.name;
  
  // Scalar types
  if (isScalarType(namedType)) {
    const scalarMapping = config.scalars?.[typeName];
    if (scalarMapping) {
      return isRequired ? scalarMapping : `${scalarMapping} | null`;
    }
    
    const defaults: Record<string, string> = {
      String: 'string',
      Int: 'number',
      Float: 'number',
      Boolean: 'boolean',
      ID: 'string'
    };
    
    const tsType = defaults[typeName] || 'unknown';
    return isRequired ? tsType : `${tsType} | null`;
  }
  
  // Enum types
  if (isEnumType(namedType)) {
    const enumName = `${config.typePrefix || ''}${typeName}${config.typeSuffix || ''}`;
    return isRequired ? enumName : `${enumName} | null`;
  }
  
  // Object/Interface/Union types - when used in FieldFn, don't add the Fields suffix
  const refName = forFieldFn 
    ? `${config.typePrefix || ''}${typeName}${config.typeSuffix || ''}Fields`
    : `${config.typePrefix || ''}${typeName}${config.typeSuffix || ''}`;
  
  return isRequired ? refName : `${refName} | null`;
}

/**
 * Generate enum type
 */
function generateEnumType(enumType: GraphQLEnumType, config: TypedBuilderPluginConfig): string[] {
  const lines: string[] = [];
  const typeName = `${config.typePrefix || ''}${enumType.name}${config.typeSuffix || ''}`;
  
  const values = enumType.getValues();
  
  lines.push(`export enum ${typeName} {`);
  for (const value of values) {
    const description = value.description ? `  /** ${value.description} */\n` : '';
    lines.push(`${description}  ${value.name} = '${value.value}',`);
  }
  lines.push('}');
  lines.push('');
  
  return lines;
}

/**
 * Generate input object type
 */
function generateInputObjectType(inputType: GraphQLInputObjectType, config: TypedBuilderPluginConfig): string[] {
  const lines: string[] = [];
  const typeName = `${config.typePrefix || ''}${inputType.name}${config.typeSuffix || ''}`;
  
  const fields = Object.values(inputType.getFields());
  
  lines.push(`export interface ${typeName} {`);
  for (const field of fields) {
    const isRequired = isNonNullType(field.type);
    const optional = isRequired ? '' : '?';
    const fieldType = generateTypeReference(field.type, config, false);
    
    const description = field.description ? `  /** ${field.description} */\n` : '';
    lines.push(`${description}  ${field.name}${optional}: ${fieldType};`);
  }
  lines.push('}');
  lines.push('');
  
  return lines;
}

/**
 * Generate object type as FieldFn interface
 */
function generateObjectTypeFields(objectType: GraphQLObjectType, config: TypedBuilderPluginConfig, schema: GraphQLSchema): string[] {
  const lines: string[] = [];
  const typeName = `${config.typePrefix || ''}${objectType.name}${config.typeSuffix || ''}Fields`;
  
  const fields = Object.values(objectType.getFields());
  
  const description = objectType.description ? `/** ${objectType.description} */\n` : '';
  lines.push(`${description}export interface ${typeName} {`);
  
  // Add __typename if requested
  if (config.includeTypename) {
    lines.push(`  __typename: FieldFn<'${objectType.name}', never, false>;`);
  }
  
  for (const field of fields) {
    lines.push(...generateFieldFn(field, config));
  }
  lines.push('}');
  lines.push('');
  
  return lines;
}

/**
 * Generate interface type as FieldFn interface
 */
function generateInterfaceTypeFields(interfaceType: GraphQLInterfaceType, config: TypedBuilderPluginConfig, schema: GraphQLSchema): string[] {
  const lines: string[] = [];
  const typeName = `${config.typePrefix || ''}${interfaceType.name}${config.typeSuffix || ''}Fields`;
  
  const fields = Object.values(interfaceType.getFields());
  
  const description = interfaceType.description ? `/** ${interfaceType.description} */\n` : '';
  lines.push(`${description}export interface ${typeName} {`);
  
  for (const field of fields) {
    lines.push(...generateFieldFn(field, config));
  }
  lines.push('}');
  lines.push('');
  
  return lines;
}

/**
 * Generate FieldFn declaration for a field
 */
function generateFieldFn(field: GraphQLField<any, any>, config: TypedBuilderPluginConfig): string[] {
  const lines: string[] = [];
  
  // Determine field return type
  const returnType = generateTypeReference(field.type, config, true);
  
  // Determine if field has arguments
  const hasArgs = field.args.length > 0;
  const argsRequired = field.args.some(arg => isNonNullType(arg.type));
  
  // Generate args type
  let argsType = 'never';
  if (hasArgs) {
    const argFields = field.args.map(arg => {
      const isRequired = isNonNullType(arg.type);
      const optional = isRequired ? '' : '?';
      const argType = generateTypeReference(arg.type, config, false);
      return `${arg.name}${optional}: ${argType}`;
    }).join('; ');
    argsType = `{ ${argFields} }`;
  }
  
  // Generate FieldFn type
  const description = field.description ? `  /** ${field.description} */\n` : '';
  const required = argsRequired ? 'true' : 'false';
  lines.push(`${description}  ${field.name}: FieldFn<${returnType}, ${argsType}, ${required}>;`);
  
  return lines;
}

/**
 * Generate union type
 */
function generateUnionType(unionType: GraphQLUnionType, config: TypedBuilderPluginConfig): string[] {
  const lines: string[] = [];
  const typeName = `${config.typePrefix || ''}${unionType.name}${config.typeSuffix || ''}Fields`;
  
  const types = unionType.getTypes();
  const typeNames = types.map(t => `${config.typePrefix || ''}${t.name}${config.typeSuffix || ''}Fields`);
  
  const description = unionType.description ? `/** ${unionType.description} */\n` : '';
  lines.push(`${description}export type ${typeName} = ${typeNames.join(' | ')};`);
  lines.push('');
  
  return lines;
}

/**
 * Validate plugin configuration
 */
export const validate: PluginValidateFn<TypedBuilderPluginConfig> = async (
  schema,
  documents,
  config,
  outputFile
) => {
  // Validate scalars if provided
  if (config.scalars) {
    if (typeof config.scalars !== 'object') {
      throw new Error('scalars must be an object mapping GraphQL scalar names to TypeScript types');
    }
  }
};



